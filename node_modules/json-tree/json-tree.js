/*
	json-tree
	author:zinkey 
*/
(function (name, factory, context) {  
    
    'use strict';

    if (typeof module != 'undefined' && module.exports) {  
        module.exports = factory();  
    }   
    else {  
        context[name] = factory();  
    }  

})("jsontree",function(){


	var isArray = [].constructor.isArray || function(src) {
		return ({}).toString.call(src) === '[object Array]';
	};

	function isObject(src) {
		return typeof src === "object" && src !== null;
	}

	function each(src, fn) {

		if (!isObject(src)) {
			return;
		}

		if (isArray(src)) {
			if (src.forEach) {
				src.forEach(fn);
			} else {
				for (var i = 0; i < src.length; i++) {
					fn(src[i], i);
				}
			}
		} else {
			for (var i in src) {
				if (src.hasOwnProperty(i)) {
					fn(src[i], i);
				}
			}
		}

	}


	return function(tree,node) {

		if (!isObject(tree)||!isObject(node)){
			throw "tree and node should be Object";
		}

		var array = [];

		function traverse(obj,node) {

			var value = obj.value;
			if (value===node){
				throw '';
			}

			if (isObject(value)){
				array.push({
					parent:value,
					key:obj.key
				});
				each(value,function(item,key){
					traverse({
						key:key,
						value:item
					},node);
				});
				array.pop();	
			}

		}

		try{
			traverse({
				value:tree
			},node);
		}
		catch(ex){
		}
		
		var index = array.length-1;
		var search = {

			parent:function(){
				index --;
				return search;
			},

			node:function(){
				
				if (index<0||index>array.length-1){
					return;
				}
				else{
					return array[index].parent;
				}
			},

			detail:function(){
				return array;
			}

		};

		return search;

	};


},this);